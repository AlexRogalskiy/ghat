'use strict';
const fs = require('fs/promises');
const del = require('del');
const path = require('path');
const yaml = require('js-yaml');
const degit = require('degit');
const globby = require('globby');
const mkdirp = require('mkdirp');
const {outdent} = require('outdent');

const temporaryDirectory = '.ghat-temp';

async function loadYamlFile(path) {
	const string = await fs.readFile(path, 'utf8').catch(() => '');
	return {
		string,
		parsed: string ? yaml.safeLoad(string) : {}
	};
}

async function applyTemplate(filename, source) {
	const localWorkflowPath = path.join('.github/workflows', path.basename(filename));
	const remoteWorkflowPath = path.join(temporaryDirectory, filename);
	const [local, remote] = await Promise.all([
		loadYamlFile(localWorkflowPath),
		loadYamlFile(remoteWorkflowPath)
	]);

	let env;
	// If either env object exist, we need to merge them and move them to the top
	if (local.parsed?.env || remote.parsed.env) {
		// Merge env objects, allowing the local to override the remote
		env = {...remote.parsed.env, ...local.parsed?.env};

		// Move the env object on top
		delete remote.parsed.env;

		// Update workflow string, only now that is necessary
		remote.string = yaml.safeDump(remote.parsed, {noCompatMode: true});
	}

	await fs.writeFile(localWorkflowPath, outdent`
		${env ? yaml.safeDump({env}) : 'env:'}
		# Generated by \`npx ghat ${source}\`
		# DO NOT EDIT BELOW

		${await remote.string}`
	);
}

async function getWorkflows() {
	// Expect to find workflows in the specified folder or "workflow template repo"
	const local = await globby('*.+(yml|yaml)', {
		cwd: temporaryDirectory
	});
	if (local.length > 0) {
		return local;
	}

	// If not, the user probably wants to copy workflows from a regular repo
	return globby('.github/workflows/*.+(yml|yaml)', {
		cwd: temporaryDirectory
	});
}

async function ghat(source) {
	const getter = degit(source, {
		force: true,
		verbose: true
	});

	const parsedPath = getter.repo.subdir && path.parse(getter.repo.subdir);
	await del(temporaryDirectory);
	await getter.clone(path.join(temporaryDirectory, (parsedPath?.ext ? parsedPath.base : '')));

	const templates = await getWorkflows();
	if (templates.length === 0) {
		throw new Error('No workflows found in ' + source);
	}

	mkdirp.sync('.github/workflows');
	await Promise.all(templates.map(template => applyTemplate(template, source)));
	await del(temporaryDirectory);
}

module.exports = ghat;
